![alt text](public/Group%2020.png)

## Aula 55 - Conhecendo server components

Server component Ã© um componente react que executa completamente no lado do servidor, isso faz com que nÃ£o inclua
javascript no lado do cliente aumentando a performance das nossas aplicaÃ§Ãµes. No nextjs, todos os componentes sÃ£o
server components por padrÃ£o, mas podemos alterar esse comportamente usando a diretiva `use client` no topo do arquivo.

No nextJs, se fizermos

```javascript
export default function Home() {
  return <div>Home</div>;
}
```

teremos um server component, e para mudar isso fazemos:

```javascript
"use client";

export default function Home() {
  return <div>Home</div>;
}
```

Agora temos um client component, onde podemos utilizar recursos como "useState", "useEffect" entre outros hooks do react.

Como mencionado acima, um server component renderiza toda informaÃ§Ã£o da pagina no lado do servidor e sÃ³ envia o HTML jÃ¡ preenchido para o client side. Para vermos melhor como isso Ã© feito, veja o cÃ³digo abaixo.

```javascript
// app/page.tsx (Server Component)
async function Page() {
  const res = await fetch("https://jsonplaceholder.typicode.com/posts/1");
  const post = await res.json();

  return (
    <div>
      <h1>{post.title}</h1>
      <p>{post.body}</p>
    </div>
  );
}

export default Page;
```

O mÃ©todo de requisiÃ§Ã£o assincrona fetch Ã© executado no lado do servidor, quando recebe os dados, preenche o componente com as informaÃ§Ãµes correspondentes e envia esse componente para ser renderizado no lado do cliente.

## Aula 56 - Revendo componentes

Nessa aula visualizamos a diferenÃ§a entre um componente react que executa no lado do client e um componente react que executa no lado do servidor, e o ponto principal entre eles Ã© que caso tenhamos uma API lenta, a pagina do client Ã© mostrada parcialmente sem os dados inseridos, uma vez que nÃ£o foram retornados pela requisiÃ§Ã£o. JÃ¡ no caso do server component a pÃ¡gina como um todo demora um pouco para ser carregada, mas todo o conteudo da pagina Ã© mostrado de uma unica vez.

## Aula 57 - Conhecendo loading

Para o caso de termos uma api lenta, podemos utilizar o recurso de loading disponivel dentro do nextJs. Esse recurso Ã© muito util para o caso de termos uma API que demora para retornar os dados, e como no nextJS a pagina nÃ£o Ã© mostrada atÃ© os dados sejam retornados pela API, temos um carregamento da pagina sem nada ser mostrado. Para evitar isso poodemos criar um loading para indicar para os usuÃ¡rio que os dados ainda estÃ£o sendo carregado.

Dentro do componente server no qual voce pretende adicionar um laoding, crie um arquivo chamado:

    loading.tsx

dentro desse arquivo, devemos, obrigatÃ³riamente, criar um componente com o nome `Loading`

```javascript
export default function Loading() {
  return (
    <div>
      <h1>Carregando...</h1>
    </div>
  );
}
```

Agora quando a API demorar responder com os dados, serÃ¡ mostrado "Carregando..." na pÃ¡gina ao invÃ©s da pÃ¡gina ficar carregando e esperando a resposta da API. Importante destacar aqui Ã© que, para adicionar loading em outros server components, fazemos o processo mostrado acima, porÃ©m criamos o arquivo loading no mesmo diretÃ³rio do arquivo `pages.tsx`.

Nesta aula ainda vimos como usar o sistema de **layout** do next, que Ã© um tipo especial de server component, uma vez que Ã© compartilhado entre as pÃ¡ginas da aplicaÃ§Ã£o sendo visivel atrÃ¡s da nevegaÃ§Ã£o entre as pÃ¡ginas. Ã‰ usado normalmente para criar headers, navbars, sidebars, footers, que sÃ£o os elementos que normalmente permanecem o mesmo em todas as rotas da aplicaÃ§Ã£o sem que precise de re-renderizaÃ§Ã£o. **Layouts** sÃ£o colocados dentro do arquivo `layout.tsx`

```javascript
import type { Metadata } from "next";
import "./globals.css";

export const metadata: Metadata = {
  title: "Create Next App",
  description: "Generated by create next app",
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode,
}>) {
  return (
    <html lang="pt-BR">
      <body>
        -> Layouts components vÃ£o dentro da tag body
        {children}
      </body>
    </html>
  );
}
```

O **Metadata** dentro do componente Ã© onde adicionamos metadados do nosso projeto que serÃ£o responsÃ¡veis por auxiliar os motores de busca do google e encontrar e recomendar nosso site.

### Criando menu como layout

Na pasta `src` crie a pasta `components` e dentro dela o arquivo, Navbar.jsx.

```javascript
import Link from "next/link";

export default function Navbar() {
  return (
    <header>
      <nav>
        <Link href={"/"}>Home</Link>
        <Link href={"/contato"}>Contato</Link>
      </nav>
    </header>
  );
}
```

Dentro do layout vamos importar o componente.

```javascript
import type { Metadata } from "next";
import "./globals.css";

import Navbar from "@/components/Navbar";

export const metadata: Metadata = {
  title: "Create Next App",
  description: "Generated by create next app",
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode,
}>) {
  return (
    <html lang="pt-BR">
      <Navbar />
      <body>{children}</body>
    </html>
  );
}
```

no exemplo acima, veremos os links em todas as rotas da aplicaÃ§Ã£o.

## Aula 58 - Evoluindo com layouts

Nesta aula aprendemos como podemos criar layouts aninhados dentro de pÃ¡ginas. Por exemplo, caso tenhamos uma rota

    /dashboard

no nosso projeto, podemos criar estruturas que serÃ£o compartilhadas entre essa rota e rotas aninhadas a ela. Vejamos um exemplo para simplificar as coisas. Suponha que tenhamos a rota mencionada acima e detro da pasta `dashboard`, criamos outra pasta com nome `settings`. Na pratica o que estamos fazendo Ã© criando uma rota aninhada que terÃ¡ como endpoint a url:

    /dashboard/settings

Caso tenhamos adicinado um layout.tsx dentro da pasta dashboard, todo componente que adicionarmos dentro desse layout serÃ¡ compartilhado somente entre as rotas dashboard e suas paginas aninhadas. Veja o exemplo de layout.tsx criado dentro da pasta `dashboard` abaixo:

```javascript
export const metadata = {
  title: "Minha pagina dashboard",
  description: "Essa Ã© a minha pagina de dashboard",
};

export default function DashboardLayout({
  children,
}: {
  children: React.ReactNode,
}) {
  return (
    <>
      <h3>Meu layout aninhado</h3>
      {children}
    </>
  );
}
```

## Aula 59 - Usando client components dentro de server components

A integraÃ§Ã£o entre um server component e client component Ã© realizado por meio de props, onde dentro do server component importamos o client component, que Ã© criado exatamente como fazemos no react, dentro da pasta components, e entÃ£o adicionamos o client component no local adequado dentro do server component e caso haja algum dado para a ser manipulado pelo client component, esse deve ser recebido via props.

### client component

```javascript
"use client";

export function Button({ repoName }) {
  return (
    <>
      <button>{repoName}</button>
    </>
  );
}
```

### server component

```javascript

// Importamos client component
import Button from '@/components/button'

interface DataProps {
  id: number,
  name: string,
  private: boolean,
  full_name: string,
  owner: {
    login: string,
    id: number,
    avatar_url: string
  }
}


async function getData() {
  try {
    await new Promise((res) => { setTimeout(res, 1000) })
    const res = await fetch('https://api.github.com/users/igorfonseca05/repos')

    return res.json()
  } catch (error) {
    console.log(error)
  }
}

export default async function Home() {

  const data: DataProps[] = await getData()

  return (
    <div>
      <h1>Bem vindo a pagina home</h1>

      <h2>RepositÃ³rios</h2>
      {data.map((item) => (
        <p key={item.id}><strong>RepositÃ³rio: </strong>{item.name}</p>
        <Button repoName={item.name}>
      ))}
    </div>
  );
}

```

Agora dentro do client components podemos utilizar hooks e alterar estados de variaveis normalmente. Essa integraÃ§Ã£o pode ser muito Ãºtil para o caso de precisarmos adicinar interatividade na nossa aplicaÃ§Ã£o.

## Aula 60 - Criando pÃ¡ginas dinÃ¢micas

Temos duas formas diferentes de criarmos pÃ¡ginas dentro do nextJs.

1ï¸âƒ£ Caso estejamos utilizando o **App Routes**(app/) devemos fazer:

      app/repos/[id]/page.tsx

2ï¸âƒ£ Caso estejamos utilizando o **Pages Routes**(pages/) fazemos:

      pages/repos/[id].tsx

Aqui utilizamos o primeiro caso, ou seja, dentro da rota **repos** criamos uma sub rota que serÃ¡ uma pagina dinamica. Dentro da rota dinamica criamos
uma pÃ¡gina utilizando o formato padrÃ£o de pÃ¡ginas no next.

```javascript
interface ParamsProps {
  params: {
    id: string,
  };
}

export default function UniqueRepo({ params }: ParamsProps) {
  if (!params?.id) return <p>Carregando...</p>;

  return (
    <>
      <div>
        <h1>pagina dinamica {params.id}</h1>
      </div>
    </>
  );
}
```

## Aula 61 - Criando grupo de paginas

Caso queiramos criar um grupo de pÃ¡ginas relacionadas num Ãºnico diretÃ³rio, devemos criar uma nova pasta com o nome entre parenteses () e mover as rotas(pastas) para dentro do grupo de pÃ¡ginas desejado. Abaixo criamos 4 grupos de paginas e dentro delas adicinamos as rotas da aplicaÃ§Ã£o. Todas as rotas serÃ£o acessiveis, porÃ©m essa tecnica mantem o cÃ³digo mais organizado.

â”£ ğŸ“‚ (Admin)  
 â”ƒ â”£ ğŸ“‚ users  
 â”ƒ â”£ ğŸ“‚ dashboard  
 â”ƒ â”— ğŸ“œ layout.tsx

â”£ ğŸ“‚ (Client)  
 â”ƒ â”£ ğŸ“‚ profile  
 â”ƒ â”£ ğŸ“‚ orders  
 â”ƒ â”— ğŸ“œ layout.tsx

â”£ ğŸ“‚ (Private)  
 â”ƒ â”£ ğŸ“‚ settings  
 â”ƒ â”£ ğŸ“‚ payments  
 â”ƒ â”— ğŸ“œ layout.tsx

â”£ ğŸ“‚ (Public)  
 â”ƒ â”£ ğŸ“‚ home  
 â”ƒ â”£ ğŸ“‚ about  
 â”ƒ â”— ğŸ“œ layout.tsx

â”— ğŸ“œ layout.tsx

## Aula 62 - Cache e revalidade

Para evitar que haja busca de dados no nossa API de maneira descessÃ¡ria, poder utilizar o revalidate ou o cache para menter os dados obtidos na primeira requisiÃ§Ã£o salvos em um CND no servidor para se enviado como resposta
