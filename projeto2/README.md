![alt text](public/Group%2020.png)

## Aula 55 - Conhecendo server components

Server component √© um componente react que executa completamente no lado do servidor, isso faz com que n√£o inclua
javascript no lado do cliente aumentando a performance das nossas aplica√ß√µes. No nextjs, todos os componentes s√£o
server components por padr√£o, mas podemos alterar esse comportamente usando a diretiva `use client` no topo do arquivo.

No nextJs, se fizermos

```javascript
export default function Home() {
  return <div>Home</div>;
}
```

teremos um server component, e para mudar isso fazemos:

```javascript
"use client";

export default function Home() {
  return <div>Home</div>;
}
```

Agora temos um client component, onde podemos utilizar recursos como "useState", "useEffect" entre outros hooks do react.

Como mencionado acima, um server component renderiza toda informa√ß√£o da pagina no lado do servidor e s√≥ envia o HTML j√° preenchido para o client side. Para vermos melhor como isso √© feito, veja o c√≥digo abaixo.

```javascript
// app/page.tsx (Server Component)
async function Page() {
  const res = await fetch("https://jsonplaceholder.typicode.com/posts/1");
  const post = await res.json();

  return (
    <div>
      <h1>{post.title}</h1>
      <p>{post.body}</p>
    </div>
  );
}

export default Page;
```

O m√©todo de requisi√ß√£o assincrona fetch √© executado no lado do servidor, quando recebe os dados, preenche o componente com as informa√ß√µes correspondentes e envia esse componente para ser renderizado no lado do cliente.

## Aula 56 - Revendo componentes

Nessa aula visualizamos a diferen√ßa entre um componente react que executa no lado do client e um componente react que executa no lado do servidor, e o ponto principal entre eles √© que caso tenhamos uma API lenta, a pagina do client √© mostrada parcialmente sem os dados inseridos, uma vez que n√£o foram retornados pela requisi√ß√£o. J√° no caso do server component a p√°gina como um todo demora um pouco para ser carregada, mas todo o conteudo da pagina √© mostrado de uma unica vez.

## Aula 57 - Conhecendo loading

Para o caso de termos uma api lenta, podemos utilizar o recurso de loading disponivel dentro do nextJs. Esse recurso √© muito util para o caso de termos uma API que demora para retornar os dados, e como no nextJS a pagina n√£o √© mostrada at√© os dados sejam retornados pela API, temos um carregamento da pagina sem nada ser mostrado. Para evitar isso poodemos criar um loading para indicar para os usu√°rio que os dados ainda est√£o sendo carregado.

Dentro do componente server no qual voce pretende adicionar um laoding, crie um arquivo chamado:

    loading.tsx

dentro desse arquivo, devemos, obrigat√≥riamente, criar um componente com o nome `Loading`

```javascript
export default function Loading() {
  return (
    <div>
      <h1>Carregando...</h1>
    </div>
  );
}
```

Agora quando a API demorar responder com os dados, ser√° mostrado "Carregando..." na p√°gina ao inv√©s da p√°gina ficar carregando e esperando a resposta da API. Importante destacar aqui √© que, para adicionar loading em outros server components, fazemos o processo mostrado acima, por√©m criamos o arquivo loading no mesmo diret√≥rio do arquivo `pages.tsx`.

Nesta aula ainda vimos como usar o sistema de **layout** do next, que √© um tipo especial de server component, uma vez que √© compartilhado entre as p√°ginas da aplica√ß√£o sendo visivel atr√°s da nevega√ß√£o entre as p√°ginas. √â usado normalmente para criar headers, navbars, sidebars, footers, que s√£o os elementos que normalmente permanecem o mesmo em todas as rotas da aplica√ß√£o sem que precise de re-renderiza√ß√£o. **Layouts** s√£o colocados dentro do arquivo `layout.tsx`

```javascript
import type { Metadata } from "next";
import "./globals.css";

export const metadata: Metadata = {
  title: "Create Next App",
  description: "Generated by create next app",
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode,
}>) {
  return (
    <html lang="pt-BR">
      <body>
        -> Layouts components v√£o dentro da tag body
        {children}
      </body>
    </html>
  );
}
```

O **Metadata** dentro do componente √© onde adicionamos metadados do nosso projeto que ser√£o respons√°veis por auxiliar os motores de busca do google e encontrar e recomendar nosso site.

### Criando menu como layout

Na pasta `src` crie a pasta `components` e dentro dela o arquivo, Navbar.jsx.

```javascript
import Link from "next/link";

export default function Navbar() {
  return (
    <header>
      <nav>
        <Link href={"/"}>Home</Link>
        <Link href={"/contato"}>Contato</Link>
      </nav>
    </header>
  );
}
```

Dentro do layout vamos importar o componente.

```javascript
import type { Metadata } from "next";
import "./globals.css";

import Navbar from "@/components/Navbar";

export const metadata: Metadata = {
  title: "Create Next App",
  description: "Generated by create next app",
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode,
}>) {
  return (
    <html lang="pt-BR">
      <Navbar />
      <body>{children}</body>
    </html>
  );
}
```

no exemplo acima, veremos os links em todas as rotas da aplica√ß√£o.

## Aula 58 - Evoluindo com layouts

Nesta aula aprendemos como podemos criar layouts aninhados dentro de p√°ginas. Por exemplo, caso tenhamos uma rota

    /dashboard

no nosso projeto, podemos criar estruturas que ser√£o compartilhadas entre essa rota e rotas aninhadas a ela. Vejamos um exemplo para simplificar as coisas. Suponha que tenhamos a rota mencionada acima e detro da pasta `dashboard`, criamos outra pasta com nome `settings`. Na pratica o que estamos fazendo √© criando uma rota aninhada que ter√° como endpoint a url:

    /dashboard/settings

Caso tenhamos adicinado um layout.tsx dentro da pasta dashboard, todo componente que adicionarmos dentro desse layout ser√° compartilhado somente entre as rotas dashboard e suas paginas aninhadas. Veja o exemplo de layout.tsx criado dentro da pasta `dashboard` abaixo:

```javascript
export const metadata = {
  title: "Minha pagina dashboard",
  description: "Essa √© a minha pagina de dashboard",
};

export default function DashboardLayout({
  children,
}: {
  children: React.ReactNode,
}) {
  return (
    <>
      <h3>Meu layout aninhado</h3>
      {children}
    </>
  );
}
```

## Aula 59 - Usando client components dentro de server components

A integra√ß√£o entre um server component e client component √© realizado por meio de props, onde dentro do server component importamos o client component, que √© criado exatamente como fazemos no react, dentro da pasta components, e ent√£o adicionamos o client component no local adequado dentro do server component e caso haja algum dado para a ser manipulado pelo client component, esse deve ser recebido via props.

### client component

```javascript
"use client";

export function Button({ repoName }) {
  return (
    <>
      <button>{repoName}</button>
    </>
  );
}
```

### server component

```javascript

// Importamos client component
import Button from '@/components/button'

interface DataProps {
  id: number,
  name: string,
  private: boolean,
  full_name: string,
  owner: {
    login: string,
    id: number,
    avatar_url: string
  }
}


async function getData() {
  try {
    await new Promise((res) => { setTimeout(res, 1000) })
    const res = await fetch('https://api.github.com/users/igorfonseca05/repos')

    return res.json()
  } catch (error) {
    console.log(error)
  }
}

export default async function Home() {

  const data: DataProps[] = await getData()

  return (
    <div>
      <h1>Bem vindo a pagina home</h1>

      <h2>Reposit√≥rios</h2>
      {data.map((item) => (
        <p key={item.id}><strong>Reposit√≥rio: </strong>{item.name}</p>
        <Button repoName={item.name}>
      ))}
    </div>
  );
}

```

Agora dentro do client components podemos utilizar hooks e alterar estados de variaveis normalmente. Essa integra√ß√£o pode ser muito √∫til para o caso de precisarmos adicinar interatividade na nossa aplica√ß√£o.

## Aula 60 - Criando p√°ginas din√¢micas

Temos duas formas diferentes de criarmos p√°ginas dentro do nextJs.

1Ô∏è‚É£ Caso estejamos utilizando o **App Routes**(app/) devemos fazer:

      app/repos/[id]/page.tsx

2Ô∏è‚É£ Caso estejamos utilizando o **Pages Routes**(pages/) fazemos:

      pages/repos/[id].tsx

Aqui utilizamos o primeiro caso, ou seja, dentro da rota **repos** criamos uma sub rota que ser√° uma pagina dinamica. Dentro da rota dinamica criamos
uma p√°gina utilizando o formato padr√£o de p√°ginas no next.

```javascript
interface ParamsProps {
  params: {
    id: string,
  };
}

export default function UniqueRepo({ params }: ParamsProps) {
  if (!params?.id) return <p>Carregando...</p>;

  return (
    <>
      <div>
        <h1>pagina dinamica {params.id}</h1>
      </div>
    </>
  );
}
```

## Aula 61 - Criando grupo de paginas

Caso queiramos criar um grupo de p√°ginas relacionadas num √∫nico diret√≥rio, devemos criar uma nova pasta com o nome entre parenteses () e mover as rotas(pastas) para dentro do grupo de p√°ginas desejado. Abaixo criamos 4 grupos de paginas e dentro delas adicinamos as rotas da aplica√ß√£o. Todas as rotas ser√£o acessiveis, por√©m essa tecnica mantem o c√≥digo mais organizado.

‚î£ üìÇ (Admin)  
 ‚îÉ ‚î£ üìÇ users  
 ‚îÉ ‚î£ üìÇ dashboard  
 ‚îÉ ‚îó üìú layout.tsx

‚î£ üìÇ (Client)  
 ‚îÉ ‚î£ üìÇ profile  
 ‚îÉ ‚î£ üìÇ orders  
 ‚îÉ ‚îó üìú layout.tsx

‚î£ üìÇ (Private)  
 ‚îÉ ‚î£ üìÇ settings  
 ‚îÉ ‚î£ üìÇ payments  
 ‚îÉ ‚îó üìú layout.tsx

‚î£ üìÇ (Public)  
 ‚îÉ ‚î£ üìÇ home  
 ‚îÉ ‚î£ üìÇ about  
 ‚îÉ ‚îó üìú layout.tsx

‚îó üìú layout.tsx

## Aula 62 - Cache e revalidade

Para evitar que haja busca de dados no nossa API de maneira descess√°ria, poder utilizar o revalidate ou o cache. Ambos s√£o **options** passadas como argumento para o m√©todo fetch, sendo o cache usado como padr√£o dentro do m√©todo, o que significa que os dados obtidos numa requisi√ß√£o s√£o armazenados pelo `fetch`. O _revalidate_ √© o tempo que um dado cacheado pelo fetch tem de vida antes do servidor ter de fazer outra requisi√ß√£o para os dados atualizados em cache novamente. Para adicionar esse recurso ao nosso projeto fazemos

```javascript
const data = await fetch("https://api.github.com/users/igorfonseca05/repos", {
  cache: "force-cache",
  revalidate: 60,
});
```

No exemplo acima o dado ser√° armazenado em cache e revalidado a cada 60 segundos, ou seja, ao final dos 60 segundos, o servidor ir√° fazer uma nova solicita√ß√£o a API externa a salvar dos novos dados em cache por mais 60 segundos.

### Quando usar esse recurso?

A tabela abaixo mostra como podemos decidir quando ou n√£o usar o recurso de cache e revalidate

| Tipo de p√°gina                              | Dados mudam?   | Melhor op√ß√£o                 |
| ------------------------------------------- | -------------- | ---------------------------- |
| P√°gina est√°tica (ex: Sobre, Termos de uso.) | N√£o            | `cache: 'force-cache'`       |
| Lista de produtos                           | Ocasionalmente | `next: { revalidate: 3600 }` |
| Not√≠cias                                    | Frequentemente | `next: { revalidate: 300 }`  |
| Dashboard em tempo real                     | Sempre         | `cache: 'no-store'`          |

## Aula 63 - Error page

Podemos criar p√°ginas de erro dentro do nosso projeto nextJS, que ser√° mostrado em tela caso de algum erro numa requisi√ß√£o, por exemplo. Dentro da pasta que aninha a p√°gina que vc quer adicionar a p√°gina de erro crie o arquivo `error.tsx`.

#### Error.tsx

```javascript
"use client";

import { useEffect } from "react";

export default function Error({
  error,
  reset,
}: {
  error: Error,
  reset: () => void,
}) {
  useEffect(() => {
    console.log(error);
  }, [error]);

  return (
    <div>
      <p>{error}</p>
      <button onClick={() => reset()}> Try again </button>
    </div>
  );
}
```

:warning: P√°ginas de error no nextJS deve sempre ser do tipo 'use client'

no c√≥digo acima temos um componente de error que recebe dois parametros como props

1. **error** = Instancia do objeto de erro lan√ßado sobre o erro
   - **error.message** = Mostra a mensagem de error original
   - **error.digest** = Um hash gerado automaticamente do erro lan√ßado. Ele pode ser usado para corresponder ao erro correspondente em logs do lado do servidor.
2. **reset** = Fun√ßao para tentar resetar a p√°gina

## Aula 64 - Not found page

Quando o usu√°rio tenta acessar uma p√°gina que n√£o existe na nossa aplica√ß√£o, ele ser√° redirecionado a uma p√°gina que n√£o existe, podemos estilizar essa p√°gina criando um arquivo na raiz do projeto ou na rota chamado `not-found.tsx`. Dentro desse arquivo fazemos:

```javascript
import Link from "next/link";

export default function NotFound() {
  return (
    <div>
      <h2>P√°gina n√£o encontrada</h2>
      <p>Essa p√°gina n√£o foi encontrada</p>
      <Link href="/">Return Home</Link>
    </div>
  );
}
```

## Aula 65 - Aplicando metadata

Metadados s√£o importantes para definir as tags `meta` e `link` dentro do HTML de modo a melhorar a visibilidade do nosso site em mec√¢nismos de buscas, sendo eles suportados somente em server components. No nextjs existem duas formas de adicionar metadados √† sua aplica√ß√£o.

- **Metadados baseados em configura√ß√£o**: exportar um objeto de metadado est√°tico ou uma fun√ß√£o dinamica `generateMetada` no layout.tsx ou `page.tsx`
- **Metadados baseados em arquivo**: Adicione arquivos especiais est√°ticos ou gerados dinamicamente aos segmentos de rota

### Static Metadata

Para definir metadados est√°ticos, exporte um objeto `Metadata` na `layout.tsx` ou `page.tsx` est√°tica:

```javascript
import type { Metadata } from "next";

export const metadata: Metadata = {
  title: "...", // Define o t√≠tulo da p√°gina
  description: "..", // Define a descri√ß√£o da p√°gina
  keywords: ['nextjs', 'javascript'], // Define palavras-chave para SEO
  openGraph: {
    images: ['url1', 'url2', ...] // Define imagens para compartilhamento em redes sociais
  },
  robots: {
    index: true, // Permite que os motores de busca indexem a p√°gina
    follow: true, // Permite que os motores de busca sigam os links da p√°gina
    nocache: true, // Impede que a p√°gina seja armazenada em cache pelos motores de busca
    googleBot: {
      index: true, // Permite que o Google indexe a p√°gina
      follow: true, // Permite que o Google siga os links da p√°gina
      noimageIndex: true // Impede que o Google indexe imagens da p√°gina
    }
  }
};

export default function Page() {}
```

O c√≥digo acima pode ser copiado e colado em todas as p√°ginas server side do nosso projeto adicionando dados especificos da p√°gina, como title e outros.

## Aula 66 - Relembrando conhecimentos

Nesta aula revisamos o que vimos acima

## Aula 67 - Conhecendo Api routes

Podemos usar a pasta Api routes para criar rotas backend dentro do nosso projeto. Para isso criamos uma pasta chamada `api` dentro da pasta `app`. Dentro da `api` criamos uma pasta que vai receber o nome da rota, por exemplo, se quisermos a rota **user** na nossa api devemos fazer

    app/
      ‚îî‚îÄ‚îÄ api/
           ‚îî‚îÄ‚îÄ user/
                  ‚îî‚îÄ‚îÄ route.ts

Agora dentro do route.ts fazemos

```javascript
import { NextResponse } from "next/server";

let tarefas = ["comprar carro", "casa"];

export async function GET(request: Request) {
  return NextResponse.json(tarefas);
}
```

para acessar essa rota dentro da nossa aplica√ß√£o, fazemos:

    http://localhost:3000/api/user

## Aula 66 - Evoluindo api routes

Podemos usar outros m√©todos HTTP

### GET

```javascript
import { NextResponse } from "next/server";

let tarefas = ["comprar carro", "casa"];

export async function GET(request: Request) {
  return NextResponse.json(tarefas);
}
```

### POST

```JAVASCRIPT
export async function POST(request: Request) {
  const data = await request.json(); // Dados que ser√£o recebidos na API
  console.log(data);

  return NextResponse.json({'Aqui colocamos uma reposta(obj,arra,string...)'});
}
```

### PUT

```JAVASCRIPT
export async function PUT(request: Request) {
    const {searchParams} = new URL(request.url) //Pega search params
    const index = searchParams.get('index');

    const data = await request.json();

    tarefas[Number(index)] = data.name

    return NextResponse.json({message: 'Tarefa atualizada com sucesso'})
}
```

### DELETE

```JAVASCRIPT
export async function DELETE(request: Request) {
    const {searchParams} = new URL(request.url) //Pega search params
    const index = searchParams.get('index'); // nome do seachParams que vc quer pegar

    const data = await request.json();

    tarefas[Number(index)] = data.name

    return NextResponse.json({message: 'Tarefa atualizada com sucesso'})
}
```
